# ParallelDev - Claude Code 自动化并行开发系统

🚀 通过 git worktree + Claude Code + 智能任务调度，实现真正的自动化并行开发，将开发效率提升 3-10 倍。

[![TypeScript](https://img.shields.io/badge/TypeScript-5.0-blue.svg)](https://www.typescriptlang.org/)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)
[![Status](https://img.shields.io/badge/Status-Architecture%20Design-orange.svg)](claudedocs/PARALLELDEV_ARCHITECTURE.md)

---

## 📋 目录

- [核心价值](#-核心价值)
- [快速开始](#-快速开始)
- [系统架构](#-系统架构)
- [核心特性](#-核心特性)
- [工作流程](#-工作流程)
- [技术栈](#-技术栈)
- [开发指南](#-开发指南)
- [路线图](#-路线图)
- [贡献指南](#-贡献指南)

---

## ✨ 核心价值

### 解决的痛点

| 传统开发痛点     | ParallelDev 解决方案              |
| ---------- | ----------------------------- |
| **开发路径丢失** | 集成 claude-task-master 精细化任务管理 |
| **无法并行开发** | 智能识别并行任务，多 worktree 物理隔离      |
| **代码冲突频繁** | 自动冲突检测 + AI 辅助解决 + 质量门禁       |
| **缺乏监控**   | 实时监控所有 Worker 状态和任务进度         |
| **需要人工值守** | 从任务生成到代码集成全流程自动化              |

### 关键能力

- ✅ **自动化**: 人工只需生成任务列表，剩下全自动执行
- ✅ **并行化**: 智能识别可并行任务，3-5x 开发速度提升
- ✅ **可靠性**: 自动冲突解决、质量检查、失败恢复
- ✅ **可观察性**: 实时监控所有 Worker 状态和任务进度
- ✅ **YAGNI 原则**: 最小可用产品，无过度设计

---

## 🚀 快速开始

### 前置要求

- Node.js >= 20.0.0
- Git >= 2.35
- tmux >= 3.0
- Claude CLI 已安装并登录

### 安装

```bash
# 克隆仓库
git clone https://github.com/your-org/parallel-dev-mcp.git
cd parallel-dev-mcp

# 安装依赖
cd happy-cli
yarn install

# 构建项目
yarn build
```

### 使用示例

```bash
# 1. 使用 claude-task-master 生成任务列表
taskmaster generate --from-prd prd.md --output tasks.json

# 2. 启动 ParallelDev
happy parallel --tasks tasks.json

# 3. 系统自动执行所有任务
# - 自动创建 worktree
# - 自动分配任务给 Worker
# - 自动解决冲突
# - 自动运行测试
# - 自动推送代码

# 4. 任务完成后自动通知
✅ 所有任务已完成！
📊 成功: 12 | 失败: 0 | 总耗时: 45 分钟
```

---

## 🏗️ 系统架构

### 架构总览

```
┌──────────────────────────────────────────────────────────────┐
│                     用户（人工值守）                          │
│              使用 claude-task-master 生成任务                │
└─────────────────────┬───────────────────────────────────────┘
                      │ tasks.json
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                   Layer 1: Task Management                  │
│  ┌──────────────┐  ┌───────────────┐  ┌─────────────────┐ │
│  │ TaskMaster   │→ │ Task DAG      │→ │ Task Scheduler  │ │
│  │ Integration  │  │ Builder       │  │                 │ │
│  └──────────────┘  └───────────────┘  └─────────────────┘ │
└─────────────────────┬───────────────────────────────────────┘
                      │ 任务队列
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                 Layer 2: Orchestration (Master)             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │         Master Orchestrator (主控制器)                │  │
│  │  • 任务调度    • Worker 管理    • 状态监控           │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────┬───────────────────────────────────────┘
                      │ Master-Worker 通信 (Socket.IO + RPC)
        ┌─────────────┼─────────────┬─────────────┐
        ▼             ▼             ▼             ▼
┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌─────────┐
│   Worker 1   │ │   Worker 2   │ │   Worker 3   │ │  ...    │
│  ┌─────────┐ │ │  ┌─────────┐ │ │  ┌─────────┐ │ │         │
│  │ Worktree│ │ │  │ Worktree│ │ │  │ Worktree│ │ │         │
│  │ task-1  │ │ │  │ task-2  │ │ │  │ task-3  │ │ │         │
│  └─────────┘ │ │  └─────────┘ │ │  └─────────┘ │ │         │
│  ┌─────────┐ │ │  ┌─────────┐ │ │  ┌─────────┐ │ │         │
│  │  Tmux   │ │ │  │  Tmux   │ │ │  │  Tmux   │ │ │         │
│  │ Session │ │ │  │ Session │ │ │  │ Session │ │ │         │
│  └─────────┘ │ │  └─────────┘ │ │  └─────────┘ │ │         │
│  ┌─────────┐ │ │  ┌─────────┐ │ │  ┌─────────┐ │ │         │
│  │ Claude  │ │ │  │ Claude  │ │ │  │ Claude  │ │ │         │
│  │  Code   │ │ │  │  Code   │ │ │  │  Code   │ │ │         │
│  └─────────┘ │ │  └─────────┘ │ │  └─────────┘ │ │         │
└──────────────┘ └──────────────┘ └──────────────┘ └─────────┘
        │             │             │
        └─────────────┴─────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│          Layer 5: Quality Assurance & Git Integration       │
│  ┌─────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │  Conflict   │  │ Test Runner  │  │  Code Validator  │  │
│  │  Resolver   │  │              │  │  (Lint/TypeCheck)│  │
│  └─────────────┘  └──────────────┘  └──────────────────┘  │
└─────────────────────┬───────────────────────────────────────┘
                      │ 推送到远程仓库
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                  Git Remote Repository                      │
│                      (main branch)                          │
└─────────────────────────────────────────────────────────────┘
```


### 核心设计原则

#### 1. 改造 Happy 而非从头开始

- ✅ 在 `happy-cli/src/parallel/` 新增模块
- ✅ 复用 Happy 的 Socket.IO + RPC + 加密 + Claude SDK
- ❌ 不修改 Happy 核心代码

#### 2. Git Worktree 物理隔离（2025 最佳实践）

- 每个 Worker 运行在独立的 worktree 中
- 真正的并行开发，无相互干扰
- 支持独立的 Git 操作和冲突解决

#### 3. 事件驱动架构

- Worker 完成任务时立即触发新任务分配
- 基于 Happy 的 Socket.IO，天然支持事件
- 高效资源利用，无空闲等待

#### 4. YAGNI 原则

- ✅ 只实现当前需要的功能
- ❌ 不考虑向后兼容
- ❌ 不考虑移动端
- ❌ 不使用 Shell 脚本（复杂逻辑用 TypeScript）

---

## 🎯 核心特性

### 1. 智能任务调度

- **任务依赖分析**: 自动构建任务依赖有向无环图（DAG）
- **并行度识别**: 智能识别可并行执行的任务集合
- **动态任务分配**: Worker 空闲时自动分配下一个可执行任务
- **优先级支持**: 支持任务优先级，紧急任务优先执行

### 2. 分层冲突解决

- **Level 1: 自动解决**: 简单冲突（格式化、lockfile、非重叠修改）
- **Level 2: AI 辅助**: 使用 Claude 分析冲突并提供解决方案
- **Level 3: 人工介入**: 复杂冲突需要人工审查和解决
- **目标**: >70% 冲突自动解决率

### 3. 全面质量保证

- **自动测试**: Worker 完成任务后自动运行相关测试
- **Lint 检查**: 自动运行 ESLint/TSLint 确保代码规范
- **类型检查**: TypeScript 类型检查确保类型安全
- **质量门禁**: 所有检查通过才允许合并代码

### 4. 实时监控

- **Worker 状态**: 实时显示所有 Worker 的状态（空闲/忙碌/错误）
- **任务进度**: 显示每个任务的执行进度和预计完成时间
- **资源使用**: 监控 CPU、内存、磁盘使用情况
- **实时日志**: 捕获所有 Worker 的输出日志

### 5. 错误恢复

- **Worker 崩溃恢复**: 自动检测 Worker 崩溃并重启
- **任务失败重试**: 失败任务自动重新分配给其他 Worker
- **心跳机制**: 每 30 秒心跳检测，>90 秒无响应标记为失败
- **会话持久化**: 支持从中断状态恢复

---

## 🔄 工作流程

### 完整生命周期

```
┌──────────────────────────────────────────────────────────────┐
│ 阶段 0: 任务准备（人工值守）                                  │
├──────────────────────────────────────────────────────────────┤
│ 1. 用户使用 claude-task-master 生成任务列表                   │
│    $ taskmaster generate --from-prd prd.md --output tasks.json│
│                                                                │
│ 2. 审查并调整任务（可选）                                      │
│    $ taskmaster review tasks.json                             │
│                                                                │
│ 3. 启动 ParallelDev 系统                                      │
│    $ happy parallel --tasks tasks.json                        │
└──────────────────────────────────────────────────────────────┘
                         │
                         ▼ 自动化开始
┌──────────────────────────────────────────────────────────────┐
│ 阶段 1: 初始化（自动）                                         │
├──────────────────────────────────────────────────────────────┤
│ 1. 加载配置和验证环境                                          │
│ 2. 加载任务列表并构建依赖图（DAG）                             │
│ 3. 启动 Master Orchestrator                                   │
│ 4. 创建 Worker 池（根据并发配置）                              │
│ 5. 启动通信服务器（Socket.IO）                                │
└──────────────────────────────────────────────────────────────┘
                         │
                         ▼
┌──────────────────────────────────────────────────────────────┐
│ 阶段 2: 任务执行循环（自动）                                   │
├──────────────────────────────────────────────────────────────┤
│ 主循环（事件驱动）:                                            │
│   WHILE 未完成全部任务:                                        │
│     1. 获取可执行任务（无依赖或依赖已完成）                    │
│     2. 等待空闲 Worker                                        │
│     3. 分配任务给 Worker:                                     │
│        a. 创建 git worktree                                   │
│        b. 创建 tmux 会话                                      │
│        c. 启动 Claude Code                                    │
│        d. 发送任务指令                                        │
│     4. 监控 Worker 状态（15 秒间隔）                           │
│     5. 接收 Worker 事件并处理                                 │
└──────────────────────────────────────────────────────────────┘
                         │
                         ▼ 任务完成事件
┌──────────────────────────────────────────────────────────────┐
│ 阶段 3: 冲突解决和集成（自动）                                 │
├──────────────────────────────────────────────────────────────┤
│ 1. Worker 提交代码到本地分支                                  │
│ 2. 拉取主分支最新代码                                         │
│ 3. 尝试 rebase（2025 最佳实践）                               │
│ 4. 冲突解决（分层策略）                                       │
│ 5. 运行质量检查（测试、lint、类型检查）                        │
│ 6. 推送到远程仓库                                             │
│ 7. Master 拉取最新代码                                        │
│ 8. 清理 worktree（如果配置允许）                              │
└──────────────────────────────────────────────────────────────┘
                         │
                         ▼ 所有任务完成
┌──────────────────────────────────────────────────────────────┐
│ 阶段 4: 完成和通知（自动）                                     │
├──────────────────────────────────────────────────────────────┤
│ 1. 生成完成报告                                               │
│ 2. 发送通知（终端/声音/Web）                                   │
│ 3. 清理资源（Worker、tmux、worktree）                         │
│ 4. 保存会话状态（支持恢复）                                   │
│ 5. 优雅退出                                                   │
└──────────────────────────────────────────────────────────────┘
```



## 📚 开发指南

### 开发前准备

1. **阅读架构文档**: 查看 [`claudedocs/PARALLELDEV_ARCHITECTURE.md`](claudedocs/PARALLELDEV_ARCHITECTURE.md)
2. **阅读开发规范**: 查看 [`CLAUDE.md`](CLAUDE.md)
3. **理解 Happy 架构**: 查看 `happy-cli/CLAUDE.md`

### 代码规范

- **函数长度**: 不超过 50 行
- **类型安全**: 禁止使用 `any`
- **错误处理**: 所有异步操作必须有 try-catch
- **注释**: 所有函数必须有 JSDoc，复杂逻辑有步骤注释
- **测试**: 至少 80% 代码覆盖率

